Я реализую функцию, которая запускает приложение gtk+, открывает окно приложения, в котором
есть поля для ввода данных о сотруднике (это уже реализовано и работает), и эти данные необходимо сохранить в базе данных asuppg.db.

Запускаю программу, ввожу необходимые данные, нажимаю кнопку "Добавить" и программа завершается с ошибкой Segmentation fault. Исправь ее


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "my_lib.h"
#include <gtk/gtk.h>
#include <sqlite3.h>

static GtkWidget *personnel_radio_button;
static GtkWidget *orders_radio_button;
static GtkWidget *warehouse_radio_button;
static GtkWidget *show_radio_button;
static GtkWidget *add_radio_button;
static GtkWidget *end_radio_button;
static GtkWidget *grid; // Объявляем grid как глобальную переменную, чтобы иметь к ней доступ из разных функций
// Глобальные переменные для элементов окна выбора подсистемы
GtkWidget *entry_username;
GtkWidget *entry_password;
GtkWidget *auth_button;

int proccess(int employee);
int check_data(char* user_name, char* password);
int switch_system_admin();
void print_error();
void the_end(void);
// int calculate_salary(char* position);
int calculate_salary( const char* position);

void warehouse_proccess(char* filename, int action, Warehouse* warehouse);
void staff_proccess(char* filename, int action, StaffHeadquarters* staff_headquarters);
void product_proccess(char* filename, int action, Order* order);
static void on_auth_button_clicked(GtkWidget *widget, gpointer data);
static void activate (GtkApplication* app, gpointer user_data);
static void on_orders_button_clicked(GtkWidget *widget, gpointer data);
// static void on_subsystem_button_clicked(GtkWidget *widget, GtkApplication* app);
static void on_warehouse_button_clicked(GtkWidget *widget, gpointer data);

// static void choose_subsystem_window(GtkApplication *app, gpointer user_data, int employee);
static void choose_subsystem_window(GtkApplication *app, gpointer user_data);
static void on_subsystem_button_clicked(GtkWidget *widget, gpointer user_data);
static void on_action_button_clicked(GtkWidget *widget, gpointer window, gpointer user_data);
static void choose_action_window(GtkApplication *app, gpointer user_data);
static void show_staff_in_window(GtkApplication *app, GtkWidget *widget, gpointer user_data);
static void add_staff(GtkApplication *app, gpointer user_data);

void select_from_staff_table(GtkListStore *store);
static void on_add_staff_clicked(GtkWidget *widget, gpointer user_data);
void add_staff_to_table(const char *name, int passport, int snils, const char *position, int salary, const char *status, const char *emp_date, int phone_num, int inn);



// void add_staff_to_table(const char *name, const char *passport, const char *snils, const char *position, const char *status, const char *emp_date, const char *phone_num, const char *inn);
// void add_staff_to_table(char *name, int passport, int snils, char *position, int salary, char *status, char *emp_date, int phone_num, int inn);
// Объявляем структуру, которая будет хранить данные
// В структуре AppData добавьте указатель на grid
typedef struct {
    GtkApplication *app;
    GtkWidget *window;
    GtkWidget *main_window;
    GtkWidget *entry_username;
    GtkWidget *entry_password;
    int employee;
    GtkWidget *grid;  // добавляем указатель на grid в структуру AppData
} AppData;

typedef struct {
    GtkApplication *app;
    GtkWidget *window;
    GtkWidget *main_window;
    GtkWidget *name;
    GtkWidget *passport;
    GtkWidget *snils;
    GtkWidget *position;
    // int salary;
    GtkWidget *status;
    GtkWidget *emp_date;
    GtkWidget *phone_num;
    GtkWidget *inn;
    GtkWidget *grid;  // добавляем указатель на grid в структуру StaffAdd
} StaffAdd;


int main(int argc, char **argv) {

    GtkApplication *app;
    int status;

    app = gtk_application_new("org.gtk.example", G_APPLICATION_FLAGS_NONE);
    g_signal_connect(app, "activate", G_CALLBACK(add_staff), NULL);
    status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);

    return status;

    // db_connect();
    // show_staff();
    // return 0;
}


static void on_add_staff_clicked(GtkWidget *widget, gpointer user_data) {
    // AppData *data = (AppData*)user_data;
    StaffAdd *data = (StaffAdd*)user_data;

    // Извлекаем данные из полей ввода
    const gchar *name = gtk_entry_get_text(GTK_ENTRY(data->name));
    int passport = atoi(gtk_entry_get_text(GTK_ENTRY(data->passport)));
    int snils = atoi(gtk_entry_get_text(GTK_ENTRY(data->snils)));
    const gchar *position = gtk_entry_get_text(GTK_ENTRY(data->position));
    int salary = calculate_salary(position); // используем calculate_salary для вычисления зарплаты
    const gchar *status = gtk_entry_get_text(GTK_ENTRY(data->status));
    const gchar *emp_date = gtk_entry_get_text(GTK_ENTRY(data->emp_date));
    int phone_num = atoi(gtk_entry_get_text(GTK_ENTRY(data->phone_num)));
    int inn = atoi(gtk_entry_get_text(GTK_ENTRY(data->inn)));

    // Вызываем функцию для добавления сотрудника в базу данных
    add_staff_to_table(name, passport, snils, position, salary, status, emp_date, phone_num, inn);

    g_slice_free(StaffAdd, data); // Освобождаем память
}




// Функция для создания графического интерфейса и добавления элементов
static void add_staff(GtkApplication *app, gpointer user_data) {
    GtkWidget *window;
    // GtkWidget *grid;
    GtkWidget *subsystem_label; // Добавляем для отображения подсистемы
    GtkWidget *button;

    window = gtk_application_window_new(app);
    gtk_window_set_title(GTK_WINDOW(window), "Добавление персонала");
    gtk_window_set_default_size(GTK_WINDOW(window), 800, 800);
    gtk_window_move(GTK_WINDOW(window), 100, 100);  // Новые координаты окна (x, y)
    // gtk_window_fullscreen(GTK_WINDOW(window));

    grid = gtk_grid_new();
    gtk_container_add(GTK_CONTAINER(window), grid);

    // Создаем виджеты для аутентификации
    GtkWidget *staff_name = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_name), "ФИО");
    gtk_grid_attach(GTK_GRID(grid), staff_name, 0, 0, 1, 1);

    GtkWidget *staff_passport = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_passport), "Паспорт");
    gtk_grid_attach(GTK_GRID(grid), staff_passport, 0, 1, 1, 1);

    GtkWidget *staff_snils = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_snils), "СНИЛС");
    gtk_grid_attach(GTK_GRID(grid), staff_snils, 0, 2, 1, 1);

    GtkWidget *staff_position = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_position), "Должность");
    gtk_grid_attach(GTK_GRID(grid), staff_position, 0, 3, 1, 1);

    GtkWidget *staff_status = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_status), "Статус");
    gtk_grid_attach(GTK_GRID(grid), staff_status, 0, 4, 1, 1);

    GtkWidget *staff_date = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_date), "Дата оформления");
    gtk_grid_attach(GTK_GRID(grid), staff_date, 0, 5, 1, 1);

    GtkWidget *staff_phone = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_phone), "Номер телефона");
    gtk_grid_attach(GTK_GRID(grid), staff_phone, 0, 6, 1, 1);

    GtkWidget *staff_inn = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_inn), "ИНН");
    gtk_grid_attach(GTK_GRID(grid), staff_inn, 0, 7, 1, 1);

    // GtkWidget *add_staff_button = gtk_button_new_with_label("Добавить");
    // gtk_grid_attach(GTK_GRID(grid), add_staff_button, 0, 8, 1, 1);

    // Создаем виджеты для выбора подсистемы
    // subsystem_label = gtk_label_new("Выберите один из вариантов:");
    // Создаем остальные виджеты для выбора подсистемы

    AppData *data = g_slice_new(AppData);
    data->app = app;
    data->entry_username = entry_username;
    data->entry_password = entry_password;
    data->grid = grid;  // Сохраняем grid в структуре AppData
    data->main_window = window;  // Сохраняем указатель на главное окно в структуре AppData

    // Запоминаем grid
    grid = grid;

    button = gtk_button_new_with_label("Добавить");
    g_signal_connect(button, "clicked", G_CALLBACK(on_add_staff_clicked), data);
    gtk_grid_attach(GTK_GRID(grid), button, 0, 8, 1, 1);
    // gtk_box_pack_start(GTK_BOX(v_box), button, FALSE, FALSE, 0);
   
    // Удаляем виджет auth_button из grid
    // gtk_container_remove(GTK_CONTAINER(grid), auth_button);


    gtk_widget_show_all(window);
    // g_signal_connect(window, "destroy", G_CALLBACK(choose_subsystem_window), NULL);
    // gtk_main();

}


// Добавляет данные персонала в базу данных
// void add_staff_to_table(char *name, int passport, int snils, char *position, int salary, char *status, char *emp_date, int phone_num, int inn) {
void add_staff_to_table(const char *name, int passport, int snils, const char *position, int salary, const char *status, const char *emp_date, int phone_num, int inn) {

    // Создадим экземпляр структуры Staff и заполним его полученными данными
    Staff new_staff;
    
    strncpy(new_staff.name, name, 100);
    new_staff.passport = passport;
    new_staff.snils = snils;
    strncpy(new_staff.position, position, 20);
    new_staff.salary = salary;
    strncpy(new_staff.status, status, 100);
    strncpy(new_staff.emp_date, emp_date, 12);
    new_staff.phone_num = phone_num;
    new_staff.inn = inn;

    // Теперь, когда у нас есть структура Staff с данными, мы можем их сохранить в базе данных
    // Реализация добавления в базу данных остается практически такой же, как и прежде

    sqlite3 *db;
    char *err_msg = 0;

    int rc = sqlite3_open("asuppg.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return;
    }

    const char *sql = "INSERT INTO Staff VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)";
    sqlite3_stmt *res;
    sqlite3_prepare_v2(db, sql, -1, &res, 0);

    sqlite3_bind_text(res, 1, new_staff.name, -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(res, 2, new_staff.passport);
    sqlite3_bind_int(res, 3, new_staff.snils);
    sqlite3_bind_text(res, 4, new_staff.position, -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(res, 5, new_staff.salary);
    sqlite3_bind_text(res, 6, new_staff.status, -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(res, 7, new_staff.emp_date, -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(res, 8, new_staff.phone_num);
    sqlite3_bind_int(res, 9, new_staff.inn);

    rc = sqlite3_step(res);
    if (rc != SQLITE_DONE) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(db));
    } else {
        fprintf(stdout, "Staff added successfully\n");
    }

    sqlite3_finalize(res);
    sqlite3_close(db);
}

void print_error() {
    printf("Error\n");
}
