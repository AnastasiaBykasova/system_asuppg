Я реализую функцию, которая запускает приложение gtk+, открывает окно приложения, в котором
есть поля для ввода данных о сотруднике (это уже реализовано и работает), и эти данные необходимо сохранить в базе данных asuppg.db.

на основе функции add_staff исправь функцию add_staff_to_table, чтобы данные при вводе (при нажатии на кнопку "Добавить")
сохранялись сначала в структуру Staff, а потом в БД.

Также исправить ошибки:

"main.c: In function ‘add_staff_to_table’:
main.c:554:31: warning: passing argument 3 of ‘sqlite3_bind_text’ makes pointer from integer without a cast [-Wint-conversion]
  554 |     sqlite3_bind_text(res, 2, passport, -1, SQLITE_TRANSIENT);
      |                               ^~~~~~~~
      |                               |
      |                               int
In file included from main.c:6:
/usr/include/sqlite3.h:4517:52: note: expected ‘const char *’ but argument is of type ‘int’
 4517 | SQLITE_API int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
      |                                                    ^~~~~~~~~~~
main.c:555:31: warning: passing argument 3 of ‘sqlite3_bind_text’ makes pointer from integer without a cast [-Wint-conversion]
  555 |     sqlite3_bind_text(res, 3, snils, -1, SQLITE_TRANSIENT);
      |                               ^~~~~
      |                               |
      |                               int
In file included from main.c:6:
/usr/include/sqlite3.h:4517:52: note: expected ‘const char *’ but argument is of type ‘int’
 4517 | SQLITE_API int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
      |                                                    ^~~~~~~~~~~
      "

Код для исправления:

// Структура Staff
typedef struct {
    // int id;
    char name[100];
    int passport;
    int snils;
    char position[20];
    int salary;
    char status[100];
    char emp_date[12];
    int phone_num;
    int inn;
} Staff;

typedef struct {
    GtkApplication *app;
    GtkWidget *window;
    GtkWidget *main_window;
    GtkWidget *entry_username;
    GtkWidget *entry_password;
    int employee;
    GtkWidget *grid;  // добавляем указатель на grid в структуру AppData
} AppData;



// Функция для создания графического интерфейса и добавления элементов
static void add_staff(GtkApplication *app, gpointer user_data) {
    GtkWidget *window;
    // GtkWidget *grid;
    GtkWidget *subsystem_label; // Добавляем для отображения подсистемы
    GtkWidget *button;

    window = gtk_application_window_new(app);
    gtk_window_set_title(GTK_WINDOW(window), "Добавление персонала");
    gtk_window_set_default_size(GTK_WINDOW(window), 800, 800);
    gtk_window_move(GTK_WINDOW(window), 100, 100);  // Новые координаты окна (x, y)
    // gtk_window_fullscreen(GTK_WINDOW(window));

    grid = gtk_grid_new();
    gtk_container_add(GTK_CONTAINER(window), grid);

    // Создаем виджеты для аутентификации
    GtkWidget *staff_name = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_name), "ФИО");
    gtk_grid_attach(GTK_GRID(grid), staff_name, 0, 0, 1, 1);

    GtkWidget *staff_passport = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_passport), "Паспорт");
    gtk_grid_attach(GTK_GRID(grid), staff_passport, 0, 1, 1, 1);

    GtkWidget *staff_snils = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_snils), "СНИЛС");
    gtk_grid_attach(GTK_GRID(grid), staff_snils, 0, 2, 1, 1);

    GtkWidget *staff_position = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_position), "Должность");
    gtk_grid_attach(GTK_GRID(grid), staff_position, 0, 3, 1, 1);

    GtkWidget *staff_status = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_status), "Статус");
    gtk_grid_attach(GTK_GRID(grid), staff_status, 0, 4, 1, 1);

    GtkWidget *staff_date = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_date), "Дата оформления");
    gtk_grid_attach(GTK_GRID(grid), staff_date, 0, 5, 1, 1);

    GtkWidget *staff_phone = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_phone), "Номер телефона");
    gtk_grid_attach(GTK_GRID(grid), staff_phone, 0, 6, 1, 1);

    GtkWidget *staff_inn = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_inn), "ИНН");
    gtk_grid_attach(GTK_GRID(grid), staff_inn, 0, 7, 1, 1);

    button = gtk_button_new_with_label("Добавить");
    g_signal_connect(button, "clicked", G_CALLBACK(on_add_staff_clicked), data);
    gtk_grid_attach(GTK_GRID(grid), button, 0, 8, 1, 1);
    // gtk_box_pack_start(GTK_BOX(v_box), button, FALSE, FALSE, 0);
   
    // Удаляем виджет auth_button из grid
    // gtk_container_remove(GTK_CONTAINER(grid), auth_button);


    gtk_widget_show_all(window);
    // g_signal_connect(window, "destroy", G_CALLBACK(choose_subsystem_window), NULL);
    // gtk_main();

}


// Добавляет данные персонала в базу данных
void add_staff_to_table(char *name, int passport, int snils, char *position, int salary, char *status, char *emp_date, int phone_num, int inn) {
    sqlite3 *db;
    char *err_msg = 0;

    int rc = sqlite3_open("asuppg.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return;
    }

    // Используем подготовленный запрос, чтобы избежать проблем с типами и SQL-инъекциями
    sqlite3_stmt *res;
    const char *sql = "INSERT INTO Staff VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)";
    sqlite3_prepare_v2(db, sql, -1, &res, 0);

    // Привязываем параметры запроса к значениям
    sqlite3_bind_text(res, 1, name, -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(res, 2, passport, -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(res, 3, snils, -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(res, 4, position, -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(res, 5, salary);
    sqlite3_bind_text(res, 6, status, -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(res, 7, emp_date, -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(res, 8, phone_num);
    sqlite3_bind_int(res, 9, inn);

    // Выполняем подготовленный запрос
    rc = sqlite3_step(res);
    if (rc != SQLITE_DONE) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(db));
    } else {
        fprintf(stdout, "Staff added successfully\n");
    }

    // Освобождаем память и закрываем базу данных
    sqlite3_finalize(res);
    sqlite3_close(db);
}




int calculate_salary( const char* position) {
    int salary = 0;
    if (strcmp(position, "Менеджер") == 0) {
        salary = 60000;
    } else if (strcmp(position, "Инженер") == 0) {
        salary = 80000;
    } else if (strcmp(position, "Аналитик") == 0) {
        salary = 70000;
    } else if (strcmp(position, "Бухгалтер") == 0) {
        salary = 65000;
    }
    return salary;
}


int main(int argc, char **argv) {

    GtkApplication *app;
    int status;

    app = gtk_application_new("org.gtk.example", G_APPLICATION_FLAGS_NONE);
    g_signal_connect(app, "activate", G_CALLBACK(add_staff), NULL);
    status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);

    return status;
}