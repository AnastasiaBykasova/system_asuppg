Есть таблица Staff в БД mysql. Она хранит 10 столбцов: id INT, Name TEXT, Passport INT, SNILS INT, Position TEXT, Salary INT, Status TEXT, Date TEXT, Phone INT, INN INT. Но при выполнении программы в окне приложения при добавлении нового сотрудника в бд (после нажатия на кнопку "Добавить") выводится ошибка "SQL error: table Staff has 10 columns but 9 values were supplied"
Исправь эту ошибку.

// Функция для создания графического интерфейса и добавления элементов
static void add_staff(GtkApplication *app, gpointer user_data) {
    GtkWidget *window;
    GtkWidget *grid;
    GtkWidget *subsystem_label; // Добавляем для отображения подсистемы
    GtkWidget *button;

    window = gtk_application_window_new(app);
    gtk_window_set_title(GTK_WINDOW(window), "Добавление персонала");
    gtk_window_set_default_size(GTK_WINDOW(window), 800, 800);
    gtk_window_move(GTK_WINDOW(window), 100, 100); 

    // grid = GTK_GRID(gtk_grid_new());
    grid = gtk_grid_new();
    gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(grid));

    // Создаем виджеты для аутентификации
    GtkWidget *staff_name = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_name), "ФИО");
    gtk_grid_attach(GTK_GRID(grid), staff_name, 0, 0, 1, 1);

    GtkWidget *staff_passport = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_passport), "Паспорт");
    gtk_grid_attach(GTK_GRID(grid), staff_passport, 0, 1, 1, 1);

    GtkWidget *staff_snils = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_snils), "СНИЛС");
    gtk_grid_attach(GTK_GRID(grid), staff_snils, 0, 2, 1, 1);

    GtkWidget *staff_position = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_position), "Должность");
    gtk_grid_attach(GTK_GRID(grid), staff_position, 0, 3, 1, 1);

    GtkWidget *staff_status = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_status), "Статус");
    gtk_grid_attach(GTK_GRID(grid), staff_status, 0, 4, 1, 1);

    GtkWidget *staff_date = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_date), "Дата оформления");
    gtk_grid_attach(GTK_GRID(grid), staff_date, 0, 5, 1, 1);

    GtkWidget *staff_phone = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_phone), "Номер телефона");
    gtk_grid_attach(GTK_GRID(grid), staff_phone, 0, 6, 1, 1);

    GtkWidget *staff_inn = gtk_entry_new();
    gtk_entry_set_placeholder_text(GTK_ENTRY(staff_inn), "ИНН");
    gtk_grid_attach(GTK_GRID(grid), staff_inn, 0, 7, 1, 1);

    // GtkWidget *add_staff_button = gtk_button_new_with_label("Добавить");
    // gtk_grid_attach(GTK_GRID(grid), add_staff_button, 0, 8, 1, 1);

    // Создаем виджеты для выбора подсистемы
    // subsystem_label = gtk_label_new("Выберите один из вариантов:");
    // Создаем остальные виджеты для выбора подсистемы

    StaffAdd *data = g_slice_new(StaffAdd);
    data->app = app;
    data->name = staff_name;
    data->passport = staff_passport;
    data->snils = staff_snils;
    data->position = staff_position;
    // data->salary = calculate_salary(data->position);
    data->status = staff_status;
    data->emp_date = staff_date;
    data->phone_num = staff_phone;
    data->inn = staff_inn;



    // data->inn = staff_inn;
    data->window = window; // Добавим окно в структуру, чтобы его можно было освободить

    // Запоминаем grid
    grid = grid;

    button = gtk_button_new_with_label("Добавить");
    g_signal_connect(button, "clicked", G_CALLBACK(on_add_staff_clicked), data);
    gtk_grid_attach(GTK_GRID(grid), button, 0, 8, 1, 1);
    // gtk_box_pack_start(GTK_BOX(v_box), button, FALSE, FALSE, 0);
   
    // Удаляем виджет auth_button из grid
    // gtk_container_remove(GTK_CONTAINER(grid), auth_button);


    gtk_widget_show_all(window);
    // g_signal_connect(window, "destroy", G_CALLBACK(choose_subsystem_window), NULL);
    // gtk_main();

}


// Добавляет данные персонала в базу данных
// void add_staff_to_table(char *name, int passport, int snils, char *position, int salary, char *status, char *emp_date, int phone_num, int inn) {
void add_staff_to_table(int id, const char *name, int passport, int snils, const char *position, int salary, const char *status, const char *emp_date, int phone_num, int inn) {

    // int salary = calculate_salary(position); // Вычисляем зарплату на основе должности
    // Создадим экземпляр структуры Staff и заполним его полученными данными
    Staff new_staff;
    new_staff.id = id;
    strncpy(new_staff.name, name, 100);
    new_staff.passport = passport;
    new_staff.snils = snils;
    strncpy(new_staff.position, position, 20);
    new_staff.salary = salary;
    strncpy(new_staff.status, status, 100);
    strncpy(new_staff.emp_date, emp_date, 12);
    new_staff.phone_num = phone_num;
    new_staff.inn = inn;

    // Теперь, когда у нас есть структура Staff с данными, мы можем их сохранить в базе данных
    // Реализация добавления в базу данных остается практически такой же, как и прежде

    sqlite3 *db;
    char *err_msg = 0;

    int rc = sqlite3_open("asuppg.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return;
    }

    const char *sql = "INSERT INTO Staff VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)";
    sqlite3_stmt *res;
    sqlite3_prepare_v2(db, sql, -1, &res, 0);
    sqlite3_bind_int(res, 1, new_staff.id);
    sqlite3_bind_text(res, 2, new_staff.name, -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(res, 3, new_staff.passport);
    sqlite3_bind_int(res, 4, new_staff.snils);
    sqlite3_bind_text(res, 5, new_staff.position, -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(res, 6, new_staff.salary);
    sqlite3_bind_text(res, 7, new_staff.status, -1, SQLITE_TRANSIENT);
    sqlite3_bind_text(res, 8, new_staff.emp_date, -1, SQLITE_TRANSIENT);
    sqlite3_bind_int(res, 9, new_staff.phone_num);
    sqlite3_bind_int(res, 10, new_staff.inn);

    rc = sqlite3_step(res);
    if (rc != SQLITE_DONE) {
        fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(db));
    } else {
        fprintf(stdout, "Staff added successfully\n");
    }

    sqlite3_finalize(res);
    sqlite3_close(db);
}

int count_id(int *count) {
    sqlite3 *db;
    *count = 0; // Инициализируем количество id значением 0
    int *id_array = NULL; // Объявляем массив id
    int min_id = 301; // Инициализируем min_id значением по умолчанию
    int rc = sqlite3_open("asuppg.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return -1;
    }

    char *sql = "SELECT id FROM Staff;";
    sqlite3_stmt *res;
    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return -1;
    }

    int step = sqlite3_step(res);
    while (step == SQLITE_ROW) {
        *count += 1; // Увеличиваем количество id
        id_array = realloc(id_array, (*count) * sizeof(int)); // Увеличиваем размер массива
        id_array[*count - 1] = sqlite3_column_int(res, 0); // Записываем id в массив
        if (id_array[*count - 1] < min_id) {
            min_id = id_array[*count - 1]; // Находим минимальный id
        }
        step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    sqlite3_close(db);
    int id = min_id;
    int fl = 0;
    for (int i = 0; (i < *count && fl == 0); i++) {
        id += 1;
        // printf("id: %d\n", id);
        for (int j = 0; j < *count; j++) {
            if (id + 1 == id_array[j]) {
                id += 1;
                fl = 1;
            }
        }
    }
    free(id_array); // Освобождаем память, выделенную для массива
    return id;
}

static void on_add_staff_clicked(GtkWidget *widget, gpointer user_data) {
    StaffAdd *data = (StaffAdd*)user_data;

    const char *name = gtk_entry_get_text(GTK_ENTRY(data->name));
    const char *passport_text = gtk_entry_get_text(GTK_ENTRY(data->passport));
    const char *snils_text = gtk_entry_get_text(GTK_ENTRY(data->snils));
    const char *position = gtk_entry_get_text(GTK_ENTRY(data->position));
    const char *status = gtk_entry_get_text(GTK_ENTRY(data->status));
    const char *emp_date = gtk_entry_get_text(GTK_ENTRY(data->emp_date));
    const char *phone_num_text = gtk_entry_get_text(GTK_ENTRY(data->phone_num));
    const char *inn_text = gtk_entry_get_text(GTK_ENTRY(data->inn));

    // Проверяем, что ни один из полученных указателей не является нулевым или строкой нулевой длины
    if (name && *name != '\0' && passport_text && *passport_text != '\0' && snils_text && *snils_text != '\0' &&
        position && *position != '\0' && status && *status != '\0' && emp_date && *emp_date != '\0' &&
        phone_num_text && *phone_num_text != '\0' && inn_text && *inn_text != '\0') {
        
        // Преобразуем текст в целые числа
        int passport = atoi(passport_text);
        int snils = atoi(snils_text);
        int phone_num = atoi(phone_num_text);
        int inn = atoi(inn_text);
        int salary = calculate_salary(position); // Вычисляем зарплату на основе должности
        int id = count_id(&id);

        // Вызываем функцию для добавления сотрудника в базу данных
        add_staff_to_table(id, name, passport, snils, position, salary, status, emp_date, phone_num, inn);
    } else {
        // Выводим сообщение об ошибке, если какой-либо из полученных указателей некорректен или данные некорректны
        printf("Ошибка: некорректные данные в полях ввода!\n");
    }

    g_slice_free(StaffAdd, data); // Освобождаем память
}